# Welcome to our template for Ionic React web and native apps!

## Getting started
To get started, run `npm install` followed by `npm prepare`.

Create a `.env` file in the root of the project and add the following:
```
SUPABASE_PROJECT_ID=<YOUR_PROJECT_REFERENCE>
REACT_APP_SUPABASE_URL=<YOUR_SUPABASE_URL>
REACT_APP_SUPABASE_ANON_KEY=<YOUR_SUPABASE_ANON_KEY>
SUPABASE_ACCESS_TOKEN=<YOUR_SUPABASE_ACCESS_TOKEN>
```
These are all found in the settings page of the Supabase project and none of them are secret.

From then on, use `npm start` or `ionic serve` for [local browser development](https://ionicframework.com/docs/developing/previewing).

### Coding Practises
This repo has code guidelines baked into a linting setup. Run `npm run fix` format your code and view linting errors.
Please set up your editor to use the `eslint` and `prettier` plugins.

For more information on our React coding practises, see the MeeW Development Wiki.

> Tip, try the [LocatorJS](https://www.locatorjs.com/) browser extension to quickly find the source of a component, by holding down "alt" while hovering over a component.

### Git setup & pipelines
Please always use the `development` as the single "truth". Pushes to this branch will deploy to the QA environment.

This branch should be kept healthy at all times, and you should never push to it without doing a reviewed pull request.

There is a `Github Action` setup to review the code on pull requests to `development`. This will verify that the code is **formatted correctly**, has **no linting errors**, can **compile** and that the **tests pass**.

When you want to add a new feature, create a new branch from `development` and name it `feature/your-feature-name`. When you are done, create a pull request to merge your branch into `development`.

When you want to fix a bug, create a new branch from `development` and name it `bugfix/your-bugfix-name`. When you are done, create a pull request to merge your branch into `development`.

We use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) for commit messages. Please use this format when committing.

The `main` branch is our release branch. This is the branch that will be deployed to production. We only merge from `development` to `main` and only when we are ready to release a new version.

### Building and testing on native devices
To build and test on native devices, please see the ionic documentation on [Android Development](https://ionicframework.com/docs/developing/android) and [iOS Development](https://ionicframework.com/docs/developing/ios).

To build the project as a webapp for production, run `npm run build`.

> Tip, try the [Ionic VSCode extension](https://marketplace.visualstudio.com/items?itemName=ionic.ionic) to easily build the project to web or native, or run scripts with the click of a button.

## Folder Structure
While all config files, build artifacts and the public folder are located in the **root directory**, the **source code, types and tests** are located in the `src` folder.

## Prebuilt Features
TBA

## Frontend Diagrams
- route diagrams
- component diagrams

## Theming
For general guidelines in styling, please see our wiki page on styling with `TailwindCSS`, `CSS Shadow parts` & `CSS modules`.

### Typography and global styling
- Reset.css
- Typography.css

### Theme Variables & Settings
- variables.css
- ionic overrides
    - for more information on how to override Ionic theming with the CSS variables, see the [Ionic Theming Documentation](https://ionicframework.com/docs/theming/themes)
    - for more information on how to override Ionic components styling using their shadow parts, see the [Ionic Theming Documentation](https://ionicframework.com/docs/theming/css-shadow-parts)
- antd config css
- tailwind overwrites for typography(?) and colors
- forcing overrides for components: ionic & antd

## State & API management

### Backend types
To visualize the **E/R diagram** for the **Supabase API schema**, please visit [the Supabase schema visualizer](https://supabase-schema.vercel.app/) and input the URL and key from your environment.

The base types of the Supabase API and Database can be autogenerated using the `npm run generate:types` command. This will generate the types in the `src/types/api.types.ts` and `src/types/database.types.ts` files.

> Note that you must first run `npx supabase login`, otherwise the command will fail with a poorly worded error.

The DB types are used to type the Supabase client (see `src/apis/supabaseClient.ts`).

The client will infer the types of all results from Supabase queries. For example like:

```typescript
import { supabase } from 'src/apis/supabaseClient';

const fetchProfile = async () => {
  // data is strongly typed
  // .from() will autocomplete to the table name
  // .select() will autocomplete to the column names, even with nested queries/joins.
  // .math, .eq and other filters will autocomplete to the correct column names and types.
  const { data, error } = await supabase.from('profile').select('*');
};
```

To get the type of the returned data, you can infer it from the query result like this:

Use the `ArrayElement<T>` helper type to extract the type of the elements of an array.

To use the type *without* having a function call / query, you can extract it from the DB, using:

```typescript
// Typed Usage Example
type Profiles = Awaited<ReturnType<typeof fetchProfile>>['data'];
type Profile = ArrayElement<Profiles>;
const fetchProfile = async () => await supabase.from('profile').select('*');
```

For more advanced examples, please see
https://supabase.com/docs/reference/javascript/select#type-hints

**Important notes:**
> - The command uses the `dotenv-cli` npm package to read the Supabase URL and ANON_KEY variables from the `.env` file, and feed it into the `openapi-typescript` command. So make sure these variables are set correctly. The command also uses Supabase CLI.

> - Because `OpenAPI` schemas may have invalid `TypeScript` characters as names, the *square brackets* are a safe way to access every property from the `api.types.ts`.

> - Since the `API Type` generator uses *JSON API*, there is no way to determine if a column is an Array. It will generate array types as string, even though Supabase handles this automatically and returns arrays. You can fix this manually in the files by changing the type, e.g. names: `string -> names: string[]`

### State management with Zustand
Global state management is handled with Zustand. Global state is used to access data such as the logged in user or settings in your app, such as dark/light mode, in all components without passing the data as a prop through the component tree.

Zustand can also persist the state, which means the data from the store is stored on the device, even if the app or website is closed. This is useful for a user state, so the app will stay logged in and not make the user login everytime they visit the webpage or open the app.

Zustand global states are reactive, just like useState in React. This means your component will re-render when the state changes and only when the state ***changes***, meaning if you set the state and the old state is equal to new state, your component won't re-render.
<br><br>

Use a hook to access the state in your component:
```typescript
import { useAuthUserStore } from 'store/user';

// Hook for getting authUser from the store.
const authUser = useAuthUserStore((state) => state.authUser);

// Hook for using the setAuthUser() function.
const setAuthUser = useAuthUserStore((state) => state.setAuthUser);

// Setting the authUser with the user Supabase returns on login.
setAuthUser(userFromSupabase);
```
Creating a store:
```typescript
// "User"-type from Supabase
import { User } from '@supabase/supabase-js';
import create from 'zustand';
import { persist } from 'zustand/middleware';

// Define the store type
type AuthUserStore {
    authUser: User | null,
    setAuthUser: (authUser: User) => void
    resetAuthUser: () => void
}

// Create the store with the before defined type
export const useAuthUserStore = create<AuthUserStore>()(
    // Persist middleware wraps the store.
    persist(
        (set) => ({
            // The authUser state
            authUser: null,
            // Functions to manipulate the state
            setAuthUser: (authUser) => set({ authUser }),
            resetAuthUser: () => set({ authUser: null })
        }),
        // This is only used, if persist middleware is used.
        {
            name: 'auth-user-storage',
            // getStorage is optional, by default the 'localStorage' is used
            getStorage: () => localstorage,
        }
    )
);
```
**Note** <br>
***Persisting*** <br>
The persist-wrapper should only be used when you want to save the data to localStorage, asyncStorage, etc.. If you do not wish to persist the state, remove the object with "name" and "getStorage" along with the persist-wrapper. <br><br>
***Folder structure***<br>
Stores are divided into different files, depending on what logically goes together. E.g: both the UserStore and the AuthUserStore are in user.ts, and a ProfileStore would also go in user.ts.

## Primary Dependencies
..list included

See wiki for more guidelines and recommendations.

## Tips & tricks

If your Ionic inputs, checkboxes, etc.. are behaving weird because of the onIonChange, you can put 
```typescript
if (e.detail.value === undefined) return;
```
in the top of your "handleChange"-function. This will help prevent unwanted triggers in your "handleChange"-function.

## Improvements
- [X] Add linting + prettier + husky
- [X] Implement type generation + API envs
- [X] Convert to Zustand
- [ ] Implement login feature + component
- [ ] Detail the folder structure
- [ ] Detail the theming
- [X] Detail the state management
- [ ] Implement and detail github actions
- [ ] Implement and detail internationalization